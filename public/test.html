<!DOCTYPE html>
<html lang="en">

<head>
	<title>Particles</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script defer src="/jquery/dist/jquery.min.js"></script>
	<link defer type="text/css" rel="stylesheet" href="/bootstrap/dist/css/bootstrap.min.css">
	<link defer rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css" integrity="sha256-46qynGAkLSFpVbEBog43gvNhfrOj+BmwXdxFgVK/Kvc=" crossorigin="anonymous">
	<script defer src="/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
	<script defer src="/js/tween.umd.js"></script>
	<script defer src="/three/build/three.min.js"></script>
	<script src="http://localhost:4000/socket.io/socket.io.js" type="text/javascript"></script>
	<link type="text/css" rel="stylesheet" href="/css/index.css">
</head>

<body>
	<div class="init-screen d-flex flex-column align-items-center hide">
		<div class="main-logo mb-2 mt-auto">
			<i class="fas fa-meteor fa-3x text-warning"></i>
		</div>
		<h3 class="mt-2 title-block">
			Particles
		</h3>
		<div class="d-flex flex-row init-screen-options init-loading justify-content-center mt-3 w-100 text-black-50">
			<span class="loading mr-2">Loading</span>
			<span class="icon">
				<i class="fas fa-spinner fa-spin fa-fw fa-lg"></i>
			</span>
		</div>
        <div class="input-group init-screen-options hide mb-auto">
            <button class="btn btn-outline-secondary init-btn m-auto btn-block" type="button">Initiate</button>
        </div>
	</div>
	<div class="loading-msg d-flex flex-column align-items-center init">
		<div class="loading-cog mb-1 mt-auto">
			<i class="fas fa-cog fa-spin fa-3x"></i>
		</div>
		<h5 class="loading-num">
			0%
		</h5>
		<div class="progress">
			<div class="progress-bar progress-bar-striped progress-bar-animated loading-progress" role="progressbar" style="width: 0%;" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"></div>
		</div>
		<h5 class="loading-text mb-auto mt-2">
			Loading assets
		</h5>
	</div>

	<div id="container"></div>

	<script type='x-shader/x-vertex' id='vertex-shader'>
    /**
    * The vertex shader's main() function must define `gl_Position`,
    * which describes the position of each vertex in screen coordinates.
    *
    * To do so, we can use the following variables defined by Three.js:
    *   attribute vec3 position - stores each vertex's position in world space
    *   attribute vec2 uv - sets each vertex's the texture coordinates
    *   uniform mat4 projectionMatrix - maps camera space into screen space
    *   uniform mat4 modelViewMatrix - combines:
    *     model matrix: maps a point's local coordinate space into world space
    *     view matrix: maps world space into camera space
    *
    * `attributes` can vary from vertex to vertex and are defined as arrays
    *   with length equal to the number of vertices. Each index in the array
    *   is an attribute for the corresponding vertex. Each attribute must
    *   contain n_vertices * n_components, where n_components is the length
    *   of the given datatype (e.g. for a vec2, n_components = 2; for a float,
    *   n_components = 1)
    * `uniforms` are constant across all vertices
    * `varyings` are values passed from the vertex to the fragment shader
    *
    * For the full list of uniforms defined by three, see:
    *   https://threejs.org/docs/#api/renderers/webgl/WebGLProgram
    **/

    precision mediump float;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform vec3 cameraPosition;

    attribute vec3 position;    // blueprint's vertex positions
    attribute vec3 color;       // only used for raycasting
    attribute vec3 translation; // x y translation offsets for an instance

    varying vec3 vColor;

    void main() {
      vColor = color;

      // set point position
      vec3 pos = position + translation;
      vec4 projected = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      gl_Position = projected;

      // use the delta between the point position and camera position to size point
      float xDelta = pow(projected[0] - cameraPosition[0], 2.0);
      float yDelta = pow(projected[1] - cameraPosition[1], 2.0);
      float zDelta = pow(projected[2] - cameraPosition[2], 2.0);
      float delta  = pow(xDelta + yDelta + zDelta, 0.5);
      gl_PointSize = 10000.0 / delta;
    }
    </script>

    <script type='x-shader/x-fragment' id='fragment-shader'>
    /**
    * The fragment shader's main() function must define `gl_FragColor`,
    * which describes the pixel color of each pixel on the screen.
    *
    * To do so, we can use uniforms passed into the shader and varyings
    * passed from the vertex shader.
    *
    * Attempting to read a varying not generated by the vertex shader will
    * throw a warning but won't prevent shader compiling.
    **/

    precision highp float;

    varying vec3 color;

    uniform float useColor;

    void main() {
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
    }
    </script>

  <script type="module">

  import Stats from '/three/examples/jsm/libs/stats.module.js';
  import { GUI } from '/three/examples/jsm/libs/dat.gui.module.js';

  import { OrbitControls } from '/three/examples/jsm/controls/OrbitControls.js';

  /**
  * Generate a scene object with a background color
  **/

  function getScene() {
    var scene = new THREE.Scene();
    scene.background = new THREE.Color(0xaaaaaa);
    return scene;
  }

  /**
  * Generate the camera to be used in the scene. Camera args:
  *   [0] field of view: identifies the portion of the scene
  *     visible at any time (in degrees)
  *   [1] aspect ratio: identifies the aspect ratio of the
  *     scene in width/height
  *   [2] near clipping plane: objects closer than the near
  *     clipping plane are culled from the scene
  *   [3] far clipping plane: objects farther than the far
  *     clipping plane are culled from the scene
  **/

  function getCamera() {
    var aspectRatio = window.innerWidth / window.innerHeight;
    var camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 100000);
    camera.position.set(0, 1, -6000);
    return camera;
  }

  /**
  * Generate the renderer to be used in the scene
  **/

  function getRenderer() {
    // Create the canvas with a renderer
    var renderer = new THREE.WebGLRenderer({antialias: true});
    // Add support for retina displays
    renderer.setPixelRatio(window.devicePixelRatio);
    // Specify the size of the canvas
    renderer.setSize(window.innerWidth, window.innerHeight);
    // Add the canvas to the DOM
    document.body.appendChild(renderer.domElement);
    return renderer;
  }

  /**
  * Generate the controls to be used in the scene
  * @param {obj} camera: the three.js camera for the scene
  * @param {obj} renderer: the three.js renderer for the scene
  **/

  function getControls(camera, renderer) {
    var controls = new OrbitControls(camera, renderer.domElement);
    controls.zoomSpeed = 0.4;
    controls.panSpeed = 0.4;
    return controls;
  }

  /**
  * Generate the points for the scene
  * @param {obj} scene: the current scene object
  **/

  function addPoints(scene) {
    // this geometry builds a blueprint and many copies of the blueprint
    var geometry  = new THREE.InstancedBufferGeometry();

    geometry.addAttribute( 'position',
      new THREE.BufferAttribute( new Float32Array( [0, 0, 0] ), 3));

    // add data for each observation
    var n = 10000; // number of observations
    var rootN = n**(1/2);
    var unit = 0;
    var cellSize = 20;
    var translations = new Float32Array( n * 3 );
    var translationIterator = 0;

    for (var i=0; i<n; i++) {
      translations[translationIterator++] = (i % rootN) * cellSize;
      translations[translationIterator++] = Math.floor(i / rootN) * cellSize;
      translations[translationIterator++] = 0;
    }

    geometry.addAttribute( 'translation',
      new THREE.BufferAttribute( translations, 3, 1 ) );

    var material = new THREE.RawShaderMaterial({
      vertexShader: document.getElementById('vertex-shader').textContent,
      fragmentShader: document.getElementById('fragment-shader').textContent,
    });

    var mesh = new THREE.Points(geometry, material);
    mesh.frustumCulled = false; // prevent the mesh from being clipped on drag
    scene.add(mesh);
  }

  /**
  * Render!
  **/

  function render() {
    requestAnimationFrame(render);
    renderer.render(scene, camera);
    controls.update();
  };

  /**
  * Main
  **/

  var scene = getScene();
  var camera = getCamera();
  var renderer = getRenderer();
  var controls = getControls(camera, renderer);
  // main
  addPoints(scene);
  render();

  </script>
</body>
</html>
